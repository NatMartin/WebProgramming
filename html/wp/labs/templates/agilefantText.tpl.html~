<h1>Agile Programming</h1>
<p>
  Agile programming recognizes two fundamental facts about programming:
  <ol>
    <li>People write and use programs</li>
    <li>Programs only break when you fix them.</li>
    <li>Only worthless programs don't need to be fixed</li>
  </ol>
</p>
<p>
  Programs describe behavior; they do not, in and of themselves, they
  do nothing, so they cannot break. Furthermore, unlike most machine
  they do not wear out; they do the same thing when they are new that
  they do when they are old. Therefore, the only time the break is
  when they are changed. If they describe the desired behavior when
  they are new, they will not suddently start describing incorrect
  behavior when they are old unless that description is changed.
</p>
<p>
  This would seem like an advantage over physical machines except that
  the physical world on which they rely does not stand still. The
  computers on which they run wear out (or, more likely, grow
  outdated). Or the behaviors they describe become unnecessary (or,
  again more likely, succumb to better options). Therefore, programs
  survive only as long as they continue to change to fit current
  needs; unless they change they die.
</p>
<p>
  Like everything in this sub-lunary sphere, program either risk
  failure or die. On the theory that it is better to burn out than it
  is to rust, agile programming was born.
</p>
<p>
  Programming grew out of traditional engineering that constructs
  physical objects. Programmers assumed that like traditionally
  engineered objects, it would follow a rational sequence of
  steps. First, the engineer needs to find out what the object is
  supposed to do (i.e., gather the requirements). Once the engineer
  understands the requirements, he or she can start thinking about how
  the object will meet them (i.e. design the object). With the design
  complete, the engineer can start building the object and, once
  built, the object needs to be maintained until it completely wears
  out. This process works well when the objects are common, such as
  bridges, but become more difficult when objects are new, such as
  space ships. Still, even with novel requirements and designs, it is
  usually too costly to build the object until experiments show that
  it is likely to work.
</p>
<p>
  Software engineers followed in the steps of traditional
  engineering. They gathered a programs requirements; designed from
  those requirements; built from the design; and then maintained the
  program. And they often failed because the only the novel parts of a
  program needs to be built; the rest can be reused. A new bridge
  needs to be built over every river; a new program can be copied to a
  new computer. Novelty means that experimentation dominates design
  time, making it difficult to esitmate because the need for
  experimentation grows from the existence of the unknown.
</p>
<p>
  Agile programming acknowledges the unknown. Instead of trying to
  collect requirements at the beginning, sufficient requirements for
  the first experiment are gathered and that first experiment produces
  code that may be part of the final result. The program grows through
  successive approximation until the users agree that it meets their
  needs. It recognizes that programs only break when they are fixed by
  maintaining that all elements of the program are contingent;
  requirements and design, as well as code, may need to be changed
  while it is being build. It recognizes that code must continue to
  change to survive by extending requirements gathering, designing and
  coding into maintenance.
</p>
<h2>Principles of Agile Development</h2>
<p>
  Agile methods developed through the 1990's, with a formalization of
  the priciples in 2001 at a meeting of most of the early development
  in Utah. These principles are:
  <ul>
    <li>
      Individuals and interactions over processes and tools
    </li>
    <li>
      Working software over comprehensive documentation
    </li>
    <li>
      Customer collaboration over contract negotiation
    </li>
    <li>
      Responding to change over following a plan
    </li>
  </ul>
</p>
<img src="img/agile_manifesto.png" alt="Agile Manifesto">
<p>
  The principles derive from the nature of software.
</p>
<ul>
  <li>
    Individuals and interactions over processes and tools: error are
    introduced when people fix software. They introduce error because
    software is complex. Managing complexity requires broad band
    communication.
  </li>
  <li>
    Working software over comprehensive documentation: working
    software is exhibiting the behavior it describes. This is the only
    thing that can really be evaluated. Documentation is description
    of description of behavior.
  </li>
  <li>
    Customer collaboration over contract negotiation: customer
    collaboration based on working software allows direct evaluation
    of the desired behavior.
  </li>
  <li>
    Responding to change over following a plan: responding to change
    allows developers keep the program alive as the world around it
    changes.
  </li>
</ul>
<p>
</p>
<ol>
  <li>
    Our highest priority is to satisfy the customer through early and
    continuous delivery of valuable software.
  </li>
  <li>
    Welcome changing requirements, even late in development. Agile
    processes harness change for the customer's competitive advantage.
  </li>
  <li>
    Deliver working software frequently, from a couple of weeks to a
    couple of months, with a preference to the shorter timescale.
  </li>
  <li>
    Business people and developers must work together daily throughout
    the project.
  </li>
  <li>
    Build projects around motivated individuals.  Give them the
    environment and support they need, and trust them to get the job
    done.
  </li>
  <li>
    The most efficient and effective method of conveying information
    to and within a development team is face-to-face conversation.
  </li>
  <li>
    Working software is the primary measure of progress.
  </li>
  <li>
    Agile processes promote sustainable development.  The sponsors,
    developers, and users should be able to maintain a constant pace
    indefinitely.
  </li>
  <li>
    Continuous attention to technical excellence and good design
    enhances agility.
  </li>
  <li>
    Simplicity--the art of maximizing the amount of work not done--is
    essential.
  </li>
  <li>
    The best architectures, requirements, and designs emerge from
    self-organizing teams.
  </li>
  <li>
    At regular intervals, the team reflects on how to become more
    effective, then tunes and adjusts its behavior accordingly.
  </li>
</ol>
<h3>References</h3>
<ul>
  <li>
    <a href="http://agilemanifesto.org/">
      Manifesto for Agile Software Development
    </a>: The origin of Agile Development
  </li>
  <li>
    <a href="http://en.wikipedia.org/wiki/Agile_software_development">
      Wikipedia: Agile Software Development
    </a>
  </li>
</ul>
<h1>Agilfant: an Agile Project Management Tool</h1>
<p>
  Agilefant is a software development management tool for agile
  software development. Agile software development is a category of
  software development processes. Agilefant can support many different
  processes; we will be using Scrum, one of the more popular agile
  techniques. Scrum is named for the Rugby scrum, where the entire
  team works together to move the ball forward.
</p>
<h2>Scrum</h2>
<p>
  The scrum process iterates through sprints. At the beginning of the
  process, the scrum team selects that highest priority work from the
  product backlog and creates a sprint backlog. The team works on the
  sprint backlog until the end of the sprint at which time the
  completed work is demonstrated. The team then reviews its process
  and chooses work for the next sprint. The diagram below outlines the
  process. It indicates that sprints should be thirty days, but they
  can be anywhere from one to four weeks.
</p>
<img src="img/640px-Scrum_process.svg.png" alt="Scrum Process">
<div class="attribution">
  By Lakeworks (Own work) [
  <a href="http://www.gnu.org/copyleft/fdl.html">GFDL</a>
  or
  <a href="http://creativecommons.org/licenses/by-sa/3.0">
    CC-BY-SA-3.0-2.5-2.0-1.0
  </a> ],
  <a href="http://commons.wikimedia.org/wiki/File%3AScrum_process.svg">
    via Wikimedia Commons
  </a>
</div>
</p>
<h3> Scrum Team </h3>
<p>
  The Scrum team is a group of programmers who work together in a
  single space (co-location). The core team (pigs) comprise: a product
  owner, development team and scrum master. The product owner
  communicates between the team and the stakeholders. He or she
  organizes and prioritizes the work the team must do. The development
  team write and test the code. The scrum master communicates with
  people outside the team to remove barriers to moving forward.
</p>
<h3>Scrum Meetings</h3>
<p>
  At the beginning of the sprint, the team meets to plan the
  sprint. The product owner should have already prioritized enough
  stories for the sprint, and the team chooses the top priority
  stories as the initial sprint backlog. They then discuss the stories
  with the product owner and estimate the amount of effort for each
  story using planning poker. With the estimates, and the technical
  understanding that has come up in the planning poker session, they
  discuss the priority of the stories with the product owner. The
  product owner has prioritized the stories based on the stakeholders'
  needs, but may not have considered technical requirements. For
  example, some stories may be more difficult to complete before
  others, and such considerations could change the product owner's
  prioritization. At the end of this meeting, the sprint backlog
  should be finalized.
</p>
<p>
  Every working morning the team holds a standup meeting where each
  member of the team says:
  <ol>
    <li>What tasks they completed yesterday.</li>
    <li>What tasks they plan to work on today.</li>
    <li>Barriers to completing their tasks</li>
  </ol>
  The standup meeting should take less than fifteen minutes. At the
  end of this meeting, each team member should be aware the tasks and
  barriers current in the team. The standup meeting allows team
  members raise problems and to offer help with others problems.
</p>
<p>
  At the end of the sprint, the team holds a demo. The demo involves
  all of the team members, the product owner, and any stakeholders who
  are available to attend. The team demonstrates each of the stories
  they have completed during the sprint. The product owner has the
  option of accepting the stories as complete or making changes and
  putting them back on the product backlog. Stakeholders may also make
  comments on the work so far.
</p>
<p>
  After the demo, the team holds a retrospective meeting to discuss
  positive and negative aspects of the completed sprint. They choose
  one or two of the negative aspects to try to improve during the
  upcoming sprint.
</p>
<h3>Test Driven Development</h3>
<h2>Agilefant</h2>
    <p>
    </p>
    <h3>References</h3>
    <ul>
      <li>
	<a href="http://en.wikipedia.org/wiki/Scrum_%28software_development%29">
	  Wikipedia: Scrum (Software Development)
	</a>
      </li>
      <li>
	<a href="https://www.scrum.org/">
	  Scrum.org: Scrum Development Organization
	</a>
      </li>
      <li>
	<a href="http://www.scrumguides.org/">
	  Scrum Guide
	</a>
      </li>
      <li>
	<a href="http://www.scrumguides.org/">
	  Scrum Alliance
	</a>
      </li>
    </ul>
    <h3>References</h3>
    <ul>
      <li>
	<a href="http://agilefant.com/support/tutorials/">
	  Agilefant Tutorial
	</a>
      </li>
    </ul>
