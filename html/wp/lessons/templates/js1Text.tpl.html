<div class="wp-text-area">
  <h1>JavaScript's Origins</h1>
  <p>
    JavaScript has some peculiarities that make it a difficult
    language to work with. These peculiarities come from its history
    and the history of programming languages.
  </p>
  <h2> Programming Languages </h2>
  <p>
    Computers can only execute programs written in machine code: and
    language in which a sequence of binary digits instructs the
    Arithmetic Logic Unit (ALU) to perform one of the ALU's primitive
    actions. The computer loads the sequence into a particular
    location in a place in the ALU called an instruction register. The
    ALU does different things based on what is in the instruction
    register, which can be interpreted as arithmetic or altering
    computer memory. The important part is that the binary digits
    changes the behavior of the machine: the contents of the
    instruction register change the way current flows through the
    machine. This sequence of binary digits is the only thing that a
    computer can really execute and every statement in any other
    language needs to be translated into machine code before it can be
    executed.
  </p>
  <p>
    Machine code improved previous schemes where the
    circuits in the ALU had to be rewired for each program: using
    machine code you only need write the program to the machine's
    memory. However, the binary digits have no logical connection to
    the instructions they represent. Assemblers read a sequence of
    code words that suggest an intended operation and replace it with
    the binary digit that corresponds to the operation. They also let
    the programmive name locations in memory, again to help the
    programmer focus on the operation of the program rather than
    struggling to remember codes and addresses.
  </p>
  <p>
    Note that assembly language is used entirely for the convenience
    of the programmer. The computer must translate the assembly
    language into machine code before it can execute it. This holds
    true for all computer languages other than machine code.
  </p>
  <p>
    Assemblers became even more convienient when macros were
    added. Macros allow one to give a name to a sequence of assembly
    language commands. The assembler replaces any macros in the
    instruction sequence with the sequence of assembly language
    commandes associated with that macro before translating the
    program into machine code.
  </p>
  <p>
    High level languages required additional processing. These
    languages have a grammar closer to human language than assembly
    language; there is no one-to-one correspondance between the
    statements of high level languages and machine languages. To
    translate these languages into machine language, the translator
    must completely rewrite the program replacing statements that make
    sense to humans with statements that make sense to the machine.
  </p>
  <h3>High Level Language</h3>
  <p>
    Early high level languages relied on mathematical models of
    computation. For example, Fortran relies on the language of
    algebra; Lisp uses lambda calculus; Prolog uses first order
    logic.
  </p>
  <p>
    The first languages such as Fortran, Cobol, Algol, and Pascal,
    allowed programmers to create programs using mathematical
    expressions such as 2 + 2, a + 2, and a * b / 2. They also
    provided statements that could change the state of the computer by
    assigning values to locations and control the order in which the
    computer did things. These languages, which are called imperative
    languages, use on Turing's model of computing. These languages
    describe unambiguously what the computer is supposed to do like the
    contents of the tape in a Universal Turing Machine.
  </p>
  <p>
    Other models of computing led to the so called declarative
    languages. Alonzo Church's model of computing, which was published
    a few months before Turing's was called the lambda calculus. Like
    Turings model, it provides a mechanical method of
    computing. Unlike Turing's model, it involves the application of
    functions, starting from the most primitive function, identity,
    which simply returns it's argument (i.e. id(x) = x).
  </p>
  <p>
    John McCarthy used the lambda calculus to create a language called
    Lisp, which computes using only function. It has a set of
    primitive functions and allows one to construct ever more complex
    functions from these simple ones.
  </p>
  <p>
    Predicate calculus is another model of computing that provides
    predicates, which are either true or false. For example equals(1,
    1) would be true wherease equals(1, 2) would be false. These
    primitive predicates can be combined to create ever more complex
    statements by using the logical connectors and, or, and not; and
    the logical quantifiers for-all and there-exists allowing you to say
    things like "for-all(x), equals(x, x)" and "there-exists(x, y),
    equals(x, y) and equals(y, 2)", which also are either true or
    false. Bertram Russel and Alfred Whitehead tried to use predicate
    logic to provide the foundation for mathmatics requested by David
    Hilbert. Kurt Godel proved that their efforts were doomed to be
    fruitless. Predicate calculus provides the basis for the language
    Prolog.
  </p>
  <p>
    Yet another model of computing, production systems, was devised by
    Emil Post. In this model, sequences of symbols are rewritten under
    the control of a set of rules. These rules state that one symbol
    should be replaces by another symbol or sequence of symbols. This
    model of computing provides the foundation for expert systems, an
    attempt to caputure human knowledge.
  </p>
  <p>
    Computer Scientists thought that declarative programming langauges
    would be easier for humans because, it was claimed, the programmer
    did not need to specify how to solve the problem, only what the
    solution should be. In the end, however, it turned out that
    describing the solution to the problem and specifying how it
    should be solved are really the same task. These languages are now
    rare, though they have influence subsequent languages. For
    example, Scheme, a dialect of lisp, had significant influence on
    JavaScript.
  </p>
  <p>
    The only declarative language still in widespread use is SQL, a
    database langauage. It derives from the relational algebra where
    relations (i.e. tables of object) are manipulated. It is not,
    however, Turing complete. That is, it cannot compute all
    computable numbers.
  </p>
  <h3>Object Oriented Langauge</h3>
  <p>
    Object oriented languages were developed to make it easier to
    capture objects in the real world. Smalltalk was invented by Alan
    Kay to make it easier to program the "Dynabook," an early
    prototype of the laptop computer.
  </p>
  <p>
    At SRI, Douglas Englebart developed a computing system that relied on
    graphical objects called icons, a pointing device called a mouse,
    and views into varous computations called windows. This computing
    system was elaborated at Xerox PARC into the Xerox Alto, the first
    production computer that provides all the features expected of
    modern computers. This is the computer that Steve Jobs saw in the
    1970's that lead to the Macintosh.
  </p>
  <p>
    This new type of computer was difficult to program using
    traditional programming methods because it provided the appearance
    of interacting with objects on the screen rather than operating
    with numbers. Underlying it all, of course, the machine still only
    computed, but the computations were interpreted by the screen as
    pixels, each number corresponding to a color in a particular
    location and by the mouse as transitions from one location on the
    screen to another. The machine performs vast numbers of
    computations to create the illustion of graphics and movement, so
    programming them in traditional langagues requres tracking many
    low level details. Object oriented programming provides a way to
    abstract away the complexities of showing pictures and reacting to
    actions.
  </p>
  <p>
    Objects provide the programming metaphore. An object captures the
    state and behavior of an object, such as its appearance and
    position. It can be alaborated with methods that specify
    particular actions that the object can do and with attributes that
    capture the objects state. For example, a car object may have a
    method <code>drive</code>, that changes the cars
    attribute <code>location</code>.
  </p>
  <h3>JavaScript</h3>
  <p>
    Like all computer languages except machine code, JavaScript needs
    to be translated into machine code that the computer can
    understand. However, JavaScript is translated only
    indirectly. Instead of being translated into machine code, the
    executed in the machine's memory, it is executed by the
    browser. That is, its commands to not instruct the computer to do
    particular thing, rather, it command the browser to do particular
    things, such a display a line of text or change the color of a
    square on the screen. The browser is a running program that uses
    the instructions to guide its operation so the machine code that
    runs when a JavaScript program runs is actually part of the
    browser's machine code.
  </p>
  <p> 
    JavaScript has spread because the first widely accepted browsers,
    Netscape and Internet Explorer, accepted it as their scripting
    language. Web designers could make much better web pages when they
    used JavaScript, so they accepted it as the default scripting
    language. 
  </p>
  <p>
    Because it is a scripting language for browsers rather than a
    language that is translated into machine code, each browser
    implements a version of the language instead of each
    machine. Languages are a set of rules about what elements in that
    language mean and meaning can be subtle to interpret. Differences
    in language interpretation has always posed a problem for
    programmers because programs that work on one computer may fail on
    another because of differences in compilers. Java was supposed to
    fix this by providing an intermediate language that could be
    implemented on any machine so one could "Write once, run
    everywhere." Wags changed this to "Write once, debuge everywhere."
  </p>
  <p>
    JavaScript suffers greater incompatibilities than most langagues
    because programs are intended to run on any type of computer that
    has access to the Web site. In traditional programming, porting a
    program to a new computer was a tedious task, but it happened
    infrequently. New browsers can be written more easily than a new
    computer can be designed and built. Worse, in the past, browsers
    competed to provide better capabilities by adding to the
    JavaScript. This meant that programs that used the special
    features of one browser would not run on other
    browsers. Currently, Internet Explorer has more incompatibilities
    with all of the other browsers, though this is changing as IE
    moves to HTML 5.
  </p>
  <h3>References</h3>
  <ul class="references">
    <li class="ref">
      <a href="http://en.wikipedia.org/wiki/JavaScript">
	JavaScript (Wikipedia)
      </a>
    </li>
    <li class="ref">
      <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">
	Prototype-based Programming (Wikipedia)
      </a>
    </li>
    <li class="ref">
      <a href="http://en.wikipedia.org/wiki/Machine_code">
	Machine Code (Wikipedia)
      </a>
    </li>
    <li class="ref">
      <a href="http://en.wikipedia.org/wiki/Assembly_language">
	Assembly Language (Wikipedia)
      </a>
    </li>
    <li class="ref">
      <a href="http://en.wikipedia.org/wiki/Lambda_calculus">
	Lambda Calculus
      </a>
    </li>
    <li class="ref">
      <a href="">
	
      </a>
    </li>
  </ul>
</div>
